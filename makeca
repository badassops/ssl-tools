#!/usr/bin/env bash
#
# Copyright 1996 - 2012 Luc Suryo <luc@suryo.com>.
# Copyright 2012 - 2015 (c) BadAssOps / Luc Suryo
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#	* Redistributions of source code must retain the above copyright
#	notice, this list of conditions and the following disclaimer.
#	* Redistributions in binary form must reproduce the above copyright
#	notice, this list of conditions and the following disclaimer in the
#	documentation and/or other materials provided with the distribution.
#	* Neither the name of the <organization> nor the
#	names of its contributors may be used to endorse or promote products
#	derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSEcw
# ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
#*
#* File		:	makeca
#*
#* Description	:	script to make a CA X500-SSL certificate
#*
#* Author	:	Luc Suryo <luc@badassops.com>
#*
#* Version	:	0.4
#*
#* Date		:	Nov 13, 2015
#*
#* History	:
#* 		Date:				Author:			Info:
#*		March 1, 1996		LIS				First Release
#*		July 20, 2010		LIS				New license
#*		Aug 10, 2012		LIS				Set Copyright to BadAssOps
#*		Nov 23, 2015		LIS				Adjusted license and made script with the standard setup
#*
# get details:
# openssl rsa -noout -text -in ca.key
# openssl x509 -noout -text -in ca.crt

_program="${0##*/}"
_author='Luc Suryo'
_copyright="Copyright 2012 - $(date "+%Y") (c) BadAssOps"
_license='License BSD, http://www.freebsd.org/copyright/freebsd-license.html'
_version='0.4'
_email='luc@badassops.com'
_summary='script to make a CA X500-SSL certificate'
_cancelled="OK : Process has been cancelled on your request."
_info="$_program $_version\n$_copyright\n$_license\n\nWritten by $_author <$_email>\n$_summary\n"
_text_before_start="This script will create your own CA certificate, this should not be used in live production!"

# Whatever script needs to be run as root and exclusive lock
_need_root=0
_need_lock=1

# working variables
_opid=$$
_hostname="${HOSTNAME%%.*}"
_work_dir=/var/tmp/"$_program"
_lockfile="$_work_dir/$_program".LOCK
_work_cert="$_work_dir/mkcert.cfg"
_echo_flag='-e'
_openssl=openssl

# Cert Variables
if [[ -f env ]] ; then
	source ./env
else
	echo "env fiel is missing"
	exit 1
fi
# need to capture now so we can use it for clean_up_upon_fail
_my_cert_name="ca"
_cert_files="${_my_cert_name}.crt ${_my_cert_name}.csr ${_my_cert_name}.index ${_my_cert_name}.serial ${_my_cert_name}.key ${_my_cert_name}.key.crypt ${_my_cert_name}.pass"

# Set interrupt handler
trap inthandler 1 2 3 4 5 9 10 12 15 23 24 25

function inthandler() {
	clean_up_upon_fail
	clean_up
	echo $_echo_flag "$_cancelled"
	exit 0
}

function clean_up_upon_fail() {
	rm -f $_cert_files > /dev/null 2>&1
	return 0
}

function clean_up() {
	rm -f "$_lockfile" > /dev/null 2>&1
	return 0
}

function help() {
	trap 1 2 3 4 5 9 10 12 15 23 24 25
	echo $_echo_flag "$_info"
	echo $_echo_flag "Usage : $_program [-h]"
	echo $_echo_flag 'No options required.'
	clean_up
	exit 0
}

function isRoot() {
	if (($(id -u) != 0)) ; then
		echo $_echo_flag "\n\t*** $_program: this script must be run as the user root ***\n" >&2
		return 1
	fi
	return 0
}

function check_running() {
	if [[ -f "$_lockfile" ]]; then
		echo $_echo_flag "*** There is already a $_program running, execution has been terminated. ***"
		echo $_echo_flag "*** If this is an error please remove the lock file: $_lockfile. ***"
		exit 2
	fi
	if ! mkdir -p "$_work_dir" > /dev/null 2>&1;then
		echo $_echo_flag "*** $_state_unknown_msg: Unable to create file working directory $_work_dir! ***"
		exit 2
	fi
	echo "$_opid" > "$_lockfile"
	return 0
}

function setup_env() {
	# make sure environment exists
	[[ ! -d certs ]] && mkdir certs
	[[ ! -f ca.serial ]] && echo '01' > ca.serial
	[[ ! -f ca.index ]] && cp /dev/null ca.index
	return 0
}

function create_key() {
	echo $_echo_flag "\t*** Generating RSA private key for CA ($_my_sec_size bit) [${_my_cert_name}.key] ***"
	$_openssl genrsa -out "$_my_cert_name".key $_my_sec_size > /dev/null 2>&1
	(( $? != 0 )) && return 1
	return 0
}

function create_csr() {
	echo $_echo_flag "\t*** Generating X.509 certificate request for CA [${_my_cert_name}.csr] ***"
	echo $_echo_flag "\t**************************************************************"
	echo $_echo_flag "\t********** DO NOT USE SAME PASSWORD AS THE KEY FILE **********"
	echo $_echo_flag "\t**************************************************************"
cat > $_work_cert <<EOT
[ req ]
default_bits					= $_my_sec_size
distinguished_name				= req_distinguished_name
attributes						= req_attributes
x509_extensions					= v3_req
string_mask						= utf8only
req_extensions					= v3_req

[ req_distinguished_name ]
countryName						= "1. Country Name             (2 letter code)"
countryName_default				= $_my_country
countryName_min					= 2
countryName_max					= 2
stateOrProvinceName				= "2. State or Province Name   (full name)    "
stateOrProvinceName_default		= $_my_state
localityName					= "3. Locality Name            (eg, city)     "
localityName_default			= $_my_city
0.organizationName				= "4. Organization Name        (eg, company)  "
0.organizationName_default		= $_my_org
organizationalUnitName			= "5. Organizational Unit Name (eg, section)  "
organizationalUnitName_default	= $_my_org Certificate Authority
commonName						= "6. Common Name              (eg, CA name)  "
commonName_max					= 64
commonName_default				= ca.$_my_domain
emailAddress					= "7. Email Address            (eg, name@fqdn)"
emailAddress_max				= 40
emailAddress_default			= $_my_email

[ req_attributes ]
challengePassword				= "The password for the request file"
challengePassword_default		= $_my_req_pass
challengePassword_min			= 4
challengePassword_max			= 20
unstructuredName				= "Organization Name"
unstructuredName_default		= $_my_org

[ v3_req ]
basicConstraints				= CA:FALSE
keyUsage						= nonRepudiation, digitalSignature, keyEncipherment
EOT

	$_openssl req -nodes -config $_work_cert -new -key "$_my_cert_name".key -out "$_my_cert_name".csr
	(( $? != 0 )) && return 1
	rm -f $_work_cert
	return 0
}

function create_cert() {
	echo $_echo_flag "\t*** Generating X.509 certificate for CA signed by itself [${_my_cert_name}.crt] ***"
cat > $_work_cert <<EOT
[ ca ]
default_ca			= CA_default

[ CA_default ]
dir					= .
certs				= \$dir
new_certs_dir		= \$dir/certs
database			= \$dir/ca.index
serial				= \$dir/ca.serial
certificate			= \$dir/ca.crt
private_key			= \$dir/ca.key

x509_extensions		= usr_cert
default_days		= $_my_valid_days
default_crl_days	= 30
default_md			= sha1
preserve			= no
policy				= policy_anything

[ policy_anything ]
countryName				= $_my_country
stateOrProvinceName		= $_my_state
localityName			= $_my_city
organizationName		= $_my_org
organizationalUnitName	= Network and System Operations
commonName				= supplied
emailAddress			= $_my_email

[ usr_cert ]
basicConstraints		= CA:FALSE
nsComment				= "$_my_org CA certificate"
subjectKeyIdentifier	= hash
authorityKeyIdentifier	= keyid,issuer
subjectAltName			= email:copy
nsCertType				= sslCA, emailCA, objsign
EOT

	$_openssl x509 -extfile $_work_cert -days $_my_valid_days -signkey "$_my_cert_name".key -in "$_my_cert_name".csr -req -out "$_my_cert_name".crt > /dev/null 2>&1
	(( $? != 0 )) && return 1
	rm -f $_work_cert 
	return 0
}

function check_cert() {
	echo $_echo_flag "\t*** Verify: matching certificate & key modulus ***"
	_modcrt=$($_openssl x509 -noout -modulus -in "$_my_cert_name".crt | sed -e 's;.*Modulus=;;')
	_modkey=$($_openssl rsa -noout -modulus -in "$_my_cert_name".key | sed -e 's;.*Modulus=;;')

	if [[ "$_modcrt" != "$_modkey" ]]; then
		echo $_echo_flag "\t!!!! $_program Error: Failed to verify modulus on resulting X.509 certificate !!!!"
		return 1
	fi

	echo $_echo_flag "\t*** Verify: matching certificate signature ***"
	$_openssl verify "$_my_cert_name".crt > /dev/null 2>&1
	if (( $? != 0 )) ; then
		echo $_echo_flag "\t!!!! $_program Error: Failed to verify signature on resulting X.509 certificate !!!!"
		return 1
	fi

	echo $_echo_flag "\t*** Enrypting RSA private key of CA with a pass phrase for security [${_my_cert_name}.key] ***"
	$_openssl rsa -des3 -in "$_my_cert_name".key -out "$_my_cert_name".key.crypt > /dev/null 2>&1
	if (( $? != 0 )) ; then
		echo $_echo_flag "\t!!!! $_program Error: Failed to Enrypting RSA private key of CA with a pass phrase !!!!"
		return 1
	fi
	return 0
}

function make_it() {
	create_key
	(( $? != 0 )) && return 1
	create_csr
	(( $? != 0 )) && return 1
	create_cert
	(( $? != 0 )) && return 1
	check_cert
	(( $? != 0 )) && return 1

	# create the password file for the CA cert, so we have it in case we forgot the password.
	echo $_echo_flag "\t*** About to Create the password file for the CA cert, so we have it in case we forgot the password ***"
	echo -n "Enter the same password one more time.."
	stty -echo
	read in_key
	stty echo
	echo "$in_key" > "$_my_cert_name".pass
	echo $_echo_flag "*** Own CA Cert. created and ready for usage. ***"
	return 0
}

function main() {
	# secret flag :)
	case $1
	in
		cleanup)	clean_up_upon_fail ; exit 0 ;;
		-h|--help)	help ; exit 0 ;;
	esac

	[[ $# != 0 ]] && help
	setup_env

	if (( $_need_root == 1 )) ; then
		 isRoot
		(( $? != 0 )) && echo $_echo_flag "$_info" && exit 255
	fi
	(( $_need_lock == 1 )) && check_running

	echo $_echo_flag "$_text_before_start"
	echo $_echo_flag "Press Enter to continue or Control-C to cancel..."
	read inKey
	make_it
	_result=$?

	(( $_result == 1 )) && clean_up_upon_fail
	clean_up
	trap 1 2 3 4 5 9 10 12 15 23 24 25
	exit $_result
}
main "$@"
